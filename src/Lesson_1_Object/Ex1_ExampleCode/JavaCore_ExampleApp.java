// Дисциплина: Java Core для тестировщиков
// Домашнее задание №1 "Класс Object"
// Студент: Алексей Пирогов
// Дата: 14.02.2022

package Lesson_1_Object.Ex1_ExampleCode;

public class JavaCore_ExampleApp {

    // Класс определяет форму и сущность объекта, то есть является логической конструкцией, служащей для
    // создания типов данных отражающих атрибуты и функционал объектов реального мира, а также является основой
    // для построения всего языка Java. Важно акцинтировать внимание, что ключевая особенность класса
    // состоит в том, что он определяет новый тип данных, которым можно пользоваться для создания объектов этого
    // типа. По сути класс - это шаблон (чертёж), по которому создаются объекты (экземпляры класса).
    // Для определения формы и сущности класса указываются данные, которые он должен содержать, а также код,
    // воздействующий на эти данные.

    public static void main(String[] args) {

        // Переменные объявленные в классе описывают свойства бущих объектов (см. пример с Cat и User), а методы - поведение,
        // функционал будущих экземпляров (объектов) класса.\
        System.out.println("\n--- Example using class Cat --------------------");
        // Объекты класса создаются по образу и подобию класса (согласно чертежу). Пример №1:
        _14_Cat newCat_1 = new _14_Cat();
        // Создание объекта происходит в два этапа (см. newCat_3). Сначала создаётся переменная, имеющая определенный тип данных
        // в неё будет записана сслыка на будущий объект (поэтому при работе с объектами и классами идёт речь о ссылочных
        // типах данных). Затем необходимо выделить память под объект, создать и положить объект в выделенную часть
        // памяти, и сохранить ссылку на этот объект в памяти и сохранить этот объект в памяти в переменную.

        // Оператор new динамически выделяет память для нового объекта. Запись new Cat(), находящаяся в правой части,
        // позволяет вызвать конструктор класса, который позволяет создать экземпляр класса

        // Инициализация полей объекта newCat_1 класса Cat c использованием операции точки:
        newCat_1.name = "Беляш";
        newCat_1.color = "белый";
        newCat_1.age = 10;

        // Пример №2:
        _14_Cat newCat_2 = new _14_Cat();
        // (!) Область памяти, в которой создаются и хранятся объекты, называется кучей (heap)
        // Для непосредственного создания объекта применяетя оператор new, который резервирует память под объект и
        // возвращает ссылку на него, в общих чертах эта ссылка представляет собой адрес объекта памяти, зарезерви-
        // рованной оператором new. Пример:
        // Инициализация полей объекта newCat_2 класса Cat c использованием операции точки:
        newCat_2.name = "Дымка";
        newCat_2.color = "Серый";
        newCat_2.age = 36;

        // Пример развернутой записи создания объекта типа Cat - newCat_3:
        _14_Cat newCat_3; // здесь объявляется ссылка на объект типа Cat (первоначальное значение равно null)
        newCat_3 = new _14_Cat(); // выделение памяти для объекта тпа Cat, в переменную newCat_3 сохраняется ссылка на него
        // (!) Оператор new динамически выделяет память для нового объекта.
        // Инициализация полей объекта newCat_3 класса Cat c использованием операции точки:
        newCat_3.name = newCat_2.name;
        newCat_3.color = newCat_1.color;
        newCat_3.age = -6;
        // Использование операции точки нарушает принципы инкапсуляции данных, а также приводит к росту количества
        // кода и увеличению вероятности появлеия ошибок

        // Переменной newCat_4 не присваивается ссылка на копию объекта newCat_3, переменные newCat_3 и newCat_4
        // будут ссылаться на одинт и тот же объект в памяти.
        _14_Cat newCat_4 = newCat_3;
        // Таким образом, любые изменения внесённые в объекте по ссылке newCat_4 окажут влияние на объект, на который
        // ссылается переменная newCat_4, поскольку это один и тот же объект в памяти.

        // Вывод информации об объектах класса Cat:
        System.out.println("Cat #1. Name: " + newCat_1.name + "; color: " + newCat_1.color + "; age: " + newCat_1.age + ".\t\t Adress in heap: " + newCat_1 + ".");
        System.out.println("Cat #2. Name: " + newCat_2.name + "; color: " + newCat_2.color + "; age: " + newCat_2.age + ".\t\t Adress in heap: " + newCat_2 + ".");
        System.out.println("Cat #3. Name: " + newCat_3.name + "; color: " + newCat_3.color + "; age: " + newCat_3.age + ".\t\t Adress in heap: " + newCat_3 + ".");
        System.out.println("Cat #4. Name: " + newCat_4.name + "; color: " + newCat_4.color + "; age: " + newCat_4.age + ".\t\t Adress in heap: " + newCat_4 + ".");

        System.out.print("\n\n--- Ввод информации об объекте и пример использование методов родительских классов: \n");
        newCat_2.animalInfo();
        newCat_2.jump();
        newCat_2.run();

        System.out.println("------------------------------------------------\n");

        System.out.println("\n--- Example using class User -------------------");
        // Объект newUser создан по согласно класса User (в соответсвии с логикой User)
        _01_User newUser = new _01_User(10, "Alex", "chief specialist", 29);
        // в переменнной не лежит весь объект, а только ссылка где его искать в памяти.
        _01_User newUser_ = new _01_User();
        newUser.info();
        newUser.changePosition("ingeneer QA");
        newUser.info();

        System.out.println("Example for creating an array with objects class User.");
        _01_User users[] = {new _01_User(), new _01_User(), new _01_User(), new _01_User()};
        // вывод информации об объектах массива users
        for (_01_User user: users) {
            user.info();
        }

        // Размещение экземпляров класса User в массиве users - экземпляров класса User
        newUser.putUserInArray(users, 0);
        newUser_.putUserInArray(users, 1);

        // При работе с суперклассами и подклассами существует возможность создать ссылку на суперкласс и записать в нее
        // объект подкласса
        _21_Human humanUser = new _01_User();
        // невозможно разместить объект класса humanUser в массиве users с использованием метода putUserInArray
        // при обращении к объекту типа User через ссылку на Human будут видны только то методы и поля, которые
        // предоставляет класс Human
        if (humanUser instanceof _01_User) {
            // при необходимости использовать метод через переменную (ссылку) humanUser, необходимо явно указать класс с
            // которым осуществляется работа: ((User)humanUser). Этот момент называется casting (закастить). Пример:
            ((_01_User)humanUser).putUserInArray(users, 2);
            // После casting можно пользоваться методами и полями из класса User!!!
            System.out.println("In variable humanUser consist instance class User!!!");
            ((_01_User)humanUser).info();
        }
        // Оперетор instanceof проверяет принадлежность объекта классу к какому-либо классу. Если в humanUser будет лежать
        // ссылка не на объект типа User и используя запись вида ((User)humanUser), это операция приведёт к ошибке в работе
        // программый (исключению ClassCastException). Чтобы избежать такой ошибки можно возпользоваться оператором instanceof,
        // который проверяет принадлежность объекта к какому-либо классу.

        // Вывод обновлённой информации об объектах массива users
        for (_01_User user: users) {
            user.info();
        }

        // Вызываемый вариант метода выбирается в зависимости от класса объекта, на который переменные ссылаются во время
        // выполнения:
        System.out.println("\n\nExample interface: ");
        _32_Client client = new _32_Client();
        _33_NewClient client1 = new _33_NewClient();
        client.exampleInterface(1);
        client1.exampleInterface(2);

        System.out.println("\n\nExample enum: ");
        Fruit fruit = Fruit.APPLE;
        System.out.println(fruit);
        // Для проверки равенства констант перечислимого типа используется операция сравнения ==
        // Перечисления можно использовать в качестве селектора в блоке switch, при этом используются
        // простые имена констант (APPLE), а не уточнённые (Fruit.APPLE).
        if (fruit == Fruit.APPLE) {
            System.out.println("fruit it's apple");
        }

        switch (fruit) {
            case ORANGE:
                System.out.println("fruit - апельсин");
                break;
            case APPLE:
                System.out.println("fruit - яблоко");
                break;
            case BANANA:
                System.out.println("fruit - банан");
                break;
            case CHERRY:
                System.out.println("fruit - вишня");
                break;
        }
    }

    // В простейшей форме перечисление - список однотипных констант, определяющих новый тип данных, в объектах которого
    // могут храниться только значения из этого списка. В качестве примера можно привести названия дней недели или месяцев
    // в году - все они являются перечислениями. Для создания перечисления используется слово enum.
    public enum Fruit {
        ORANGE, APPLE, BANANA, CHERRY
    }
}