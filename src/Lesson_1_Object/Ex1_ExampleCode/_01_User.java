// (!) Имя класса должно совпадать с именем файла, в котором он объявлен,
// т.е. класс User должен находиться в одноменном файле (User.java), что
// ллюстрирует данный документ

package Lesson_1_Object.Ex1_ExampleCode;

public class _01_User extends _21_Human implements _02_ExampleInterface
{
    // Созданный тип данных определяется путем определения атрибутов (полей класса) с их типизацией,
    // а также описанием методов, отвечающих за способы обработки полей класса. С ограничением доступа
    // при помощи модификатора доступа. Например, модификатор доступа private - значит, что атрибуты
    // будут доступны только внутри этого класса

    // Перечень арибутов (свойств, полей класса) для будщего объекта класса User:
    private int id;             // дентификаторв
    private String name;        // имя
    private String position;    // должность
    private int age;            // возраст

    // Переменные, объявленные в классе описывают свойства будущих объектов, то есть являются полями экземпляра,
    // Каждый объект (экземпляр) класса содержит собственные копии этих переменных, а изменение значение поля у одного
    // объекта никак не повлияет на это же поле другого объекта

    // Пример поля для с модификатором доступа static:
    private static int counterObject;       // поле для подстчёта количества объектов класса

    // Здесь важно упомянуть, что код может содержаться либо в теле метода, либо в блоках инициализации
    // и не может "висеть в воздухе". Приимер:
    // id++;

    // Корректное оформление кода, но будет использовано не всегда, т.к. имеется конструктор с явным указанием поля id в аргументах
    {
        counterObject++;
        this.id = counterObject;
    }

    // Инициализатор для зануления счётчика количества объектов
    static {
        counterObject = 0;
    }

    // Для автоматизированной инициализации объектов при в процессе создания экземпляров класса используются конструкторы.
    // Конструктор - специальный метод, который вызывается при создании нового экземпляра класса. Конструктор всегда есть
    // у класса, даже если реализация этого метода не прописана. Java автоматичеки создаёт пустой конструктор по-умолчанию.
    // Конструктор определят действия, выполняемые при создании объекта класса, и является важной частью класса. В отличии
    // от метода класса или экземпляра класса конструктор никогда ничего не возвращает.

    // Пример непараметризированного констркутора класса User:
    private void User() {
        System.out.println("Create new object type of \"User\". Id: " + id + ".");
    }

    // При выозове конструктора хорошей идеей будет передать параметры будущего объекта в виде аргументов функции, поэтому
    // в Java имеется параметризированный конструктор. Набор полей, которые будут заполнены в экземпляре класса с помощью
    // конструктора определяет в соответстви с логикой программы. Данный аспект исключает необходимость обращения к полям
    // объекта класса с использованием операции точки (см. параметризированный конструктор User).

    // Перегрузка конструктора по-умолчанию. Как только была создана пользовательская реализация конструктора, конструкторо
    // по умолчанию автоматически создаваться не будет. Если понадобится форма без исользования аргументов, то явным образом
    // следует определить констрктор класса по-умолчанию
    public _01_User() {
        // super(); //вызов конструктора родительского класса
    }

    // Перегруженный параметризированный конструктор класса User с атрибутами, инициализирующими поля экземпляра класса
    public _01_User(int id, String name, String position, int age) {
        // Ключевое слово this требутся для того, чтобы метод мог сослаться на вызвавший его объект. Для этой цели в Java
        // определено ключевой слово this. Этим словом можно воспользоваться в теле любого нестатического метода для ссылки на
        // текущий объект, т.е. объект у которого был вызван этот метод.
        // Наиболе часто ключевоеслово this применяется в конструкторах класса и используется для обращения к полям экземпляра
        // класса и позволяет адресовать поле объекта и присвоить этому полю значение аргумента, передаваемого в констрктор.
        // Иллюстрация сказанного:
        this.id = id;
        this.name = name;
        this.position = position;
        this.age = age;
        System.out.println("Create new object type of \"User\". Id: " + id + ".");
    }

    // Инкапсуляция - связывает данные с манипулирующими данными и кодом, что позволяет управлять доступом к членам класса
    // из отдельных частей программы, предоставляя доступ только с помощью определённого ряда методов, что позволяет
    // предотвратить злоупотребление этими данными, то есть класс должен представлять собой "черный ящик", которым можно
    // пользоваться, но его внутренний механизм защищен от повреждений.
    // Инкапсуляция говорит о том, что доступ к данным объекта должен осуществляться только через методы.

    // Способ доступа к члену класса определяется модификатором доступа, присутствующим в его объявлении. Аспекты управления
    // управления доступом связаны, главным образом, с наследованием и пакетами. В Java определяются
    // следующие модификаторы доступа: public, private, protected и default. Модификатор доступа предшествует остальной части
    // спецификации типа члена.

    // Public - член класса доступен из любой части программы.
    // Private - доступен только внутри класса, в котором объявлен.
    // Default - если в объявлении члена класса отсутствует явно указанный модификатор доступа, то он
    // доступен для подклассов и других классов из данного пакета.
    // Protected - если же требуется, чтобы элемент был доступен за пределами его текущего пакета, но только классам,
    // непосредственно производным от данного класса.

    // Метод контекста объекта для вывода информации о пользователе
    public void info() {
        System.out.println("\nInfo about user:\nid: " + id + ";\nname: " + name + ";\nposition: " + position + ";\nage: " + age +".");
    }

    // Метод контекста объекта для смены позиции
    public void changePosition(String position) {
        this.position = position;
        System.out.println("\nUser " + name + " change position. New position: " + position + ".");
    }

    // Метод экземпляра класса для размещения текущего объекта в массив объктов User
    public void putUserInArray(_01_User[] users, int arrayIndex) {
        // При выполнении метода ключевое слово this укажет на объект у которого был вызван настоящий метод
        users[arrayIndex] = this;
    }

    @Override
    public void exampleInterface(int var1) {

    }

    @Override
    public void function() {

    }
}

