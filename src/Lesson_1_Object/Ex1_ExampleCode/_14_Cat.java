package Lesson_1_Object.Ex1_ExampleCode;

    // В целях сокращения кода применяется процедура наследования классов, при это родительский класс / скперкласс содержит
    // в себе некоторую уникальную информацию, которая может быть использована в классах потомках.
    // Так подкласс Cat включает в себя все члены своего суперкласса HomeAnimal. Именно по этому объект класса cat
    // имеет доступ к методу animalInfo() класса HomeAnimal и методам jump() и run() класса Animal
    // Несмотря на то, что класс HomeAnimal является суперклассом для Cat, он остаётся полностью независимым и
    // самостоятельным классом, но с ограничением вводимым модификатором abstract.
    // При отсутствии модификатора abstract возможно было использовать класс родитель для создания объектов, то есть
    // использовать как полностью самостоятельный класс.

    // (!) Так как Java не поддерживает множественное наследование, то для каждого создаваемого класса можно указать
    // только один суперкласс. Если суперкласс не указан явно, то класс наследуется от класса java.lang.Object. Абсолютно
    // все классы в Java являются прямыми или косвенными наследниками класса Object (из пакета java.lang)!

public class _14_Cat extends _13_HomeAnimal {

    // Перечень атрибутов (полей) для будущего объекта класса
    // модификатор доступа default - доступен по умолчанию от всюду
    String color;
    int age;

    // Иллюстрация работы ключевого слова super:
    private int privateVarCat;
    protected int protectedVarCat;

    // Ключевое слово super озачает обращение к суперклассу, при этом у ключевого слова имеются две общие формы. Первая
    // форма служит для вызова констрктора суперкласса, вторая - для обращения к члену суперкласса, скрываемому членом
    // подкласса. Из подкласса можно вызвать констрктор, определенный в его суперклассе. Пример:
    public _14_Cat() {
        super();        // <- здесь происходит такой вызов super
    }

    // Существует две формы super: super() - для вызова констркутора суперкласса; super.<field> - для обращения к полям
    // суперкласса. Описание и пример первой формы:

    // Если в конструкторе дочернего класса происходит вызов конструктора суперкласса (super()), то этот вызов должен
    // быть первым оператором, выполняемым в конструкторе подкласса. Если этого не сделать, то Java сама первой строкой
    // в конструкторе подкласса будет осуществлть вызов конструктора по умолчанию из суперкласса.

    // Пример обращения к полю private родительского класса через super
    public _14_Cat(int privateVarCat, int protectedVarCat) {
        super(protectedVarCat);             // <- и здесь происходит вывзов super
        this.privateVarCat = privateVarCat;
    }

    // Перегруженный параметризированный конструктор класса Cat:
    public _14_Cat(String color, int age) {
        this.color = color;
        this.age = age;
    }

    // Перегруженный параметризированный конструктор класса Cat:
    public _14_Cat(String name, String color, int age) {
        this.name = name;
        this.color = color;
        this.age = age;
    }

    // Пример метода класса для обращения к полям типа protected с использованием super:
    public void setProtectedFieldInCurrentAndParrentClass () {
        protectedVarCat = 10;   // обращение к полю типа protected в текущем классе
        super.protectedVarHomeAnimal = 100; // <- использования ключевого слова super
    }
    // Вторая форма super действует подобно ключевому слову this, за исключением того, что ссылка указывает на суперкласс.
    // Вторая форма наиболее пригодна в тех случаях, когда имена членов подкласса скрывают члены суперкласса с такими же
    // именами.

    // Метод экземпляра класса для размещения текущего объекта в массив объктов Cat
    public void putMeInArray(_14_Cat[] cats, int arrayIndex) {
        cats[arrayIndex] = this;
    }

    // Если у суперкласса и подкласса совпадают сигнатуры методов, то говорят, что метод из подкласса переопределяет метод
    // из суперкласса. Когда переопределённый метод вызывается из своего подкласса, он всегда ссылается на свой вариант,
    // определённый в подклассе. А вариант метода, определённого в суперклассе, будет скрыт.
    @Override
    public void voice() {
        System.out.println(name + " мяукнул!");
    }

    // Над методами подклассов, переопределяющими методы суперклассов, можно ставить аннотацию @Override, но она является
    // обязательной. Она всего лишь проверит, действительно ли в родительском классе есть такой метод, который требуется
    // переопределять.
    @Override
    void createChild() {
        System.out.println("Количество кошачьих прибавилось, вот она новая жизнь!");
    }

    // Если при переопределении метода необходим функционал из этого метода суперкласса, то можно использовать конструкцию
    // super.method()
    @Override
    void voiceForCreateChild() {
        // super.voiceForCreateChild(); <-- нельзя использовать, т.к. метод в суперклассе определён как абстрактный
        System.out.println(name + " издал ор для реализации инстинкта продолжения рода!");
    }
    // (!) Переопределение методов выполняется только в том случае, если имя, список аргументов и возвращаемый тип обоих
    // методов одинаковы. В противном случае оба метода считаются перегруженными. Переопределённые методы позволяют
    // поддерживать в Java полиморфизм во время выполнения, он позволяет определить в общем классе методы, которые станут
    // общими для всех производных от него классов, а в подклассах - конкретные реализации некоторых или всех этих методов.
}
